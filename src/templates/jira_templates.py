"""Jira issue field builders using Atlassian Document Format (ADF)."""

from __future__ import annotations

import re

from src.config import settings
from src.schemas.events import NotificationBundle, PROpenedEvent, RecoveryCompleteEvent


def _text_node(text: str) -> dict:
    return {"type": "text", "text": text}


def _bold_text(text: str) -> dict:
    return {"type": "text", "text": text, "marks": [{"type": "strong"}]}


def _link_node(text: str, href: str) -> dict:
    return {
        "type": "text",
        "text": text,
        "marks": [{"type": "link", "attrs": {"href": href}}],
    }


def _paragraph(*inline: dict) -> dict:
    return {"type": "paragraph", "content": list(inline)}


def _heading(text: str, level: int = 3) -> dict:
    return {
        "type": "heading",
        "attrs": {"level": level},
        "content": [_text_node(text)],
    }


def _repo_name(repo_url: str) -> str:
    return repo_url.rstrip("/").split("/")[-1] if repo_url else "unknown"


def _label_slug(value: str) -> str:
    return re.sub(r"[^a-z0-9_-]+", "-", value.lower()).strip("-")[:255] or "unknown"


def _bullet_list(*items: str) -> dict:
    return {
        "type": "bulletList",
        "content": [
            {"type": "listItem", "content": [_paragraph(_text_node(item))]}
            for item in items
        ],
    }


def _generated_by_paragraph() -> dict:
    return _paragraph(
        _bold_text("Generated by: "),
        _text_node("Devin via notification-service"),
    )


def _default_issue_summary(event: PROpenedEvent) -> str:
    return f"[ACCR] {event.target_service}: review downstream PR for {_repo_name(event.source_repo)} change"


def _base_labels(event: PROpenedEvent) -> list[str]:
    return [
        "contract-change",
        "devin-remediation",
        f"service-{_label_slug(event.target_service)}",
        f"repo-{_label_slug(_repo_name(event.target_repo))}",
    ]


def _doc_from_plain_text(text: str) -> dict:
    chunks = [chunk.strip() for chunk in re.split(r"\n\s*\n", text or "") if chunk.strip()]
    content: list[dict] = []
    for chunk in chunks:
        lines = [line.strip() for line in chunk.splitlines() if line.strip()]
        bullet_items = [re.sub(r"^[\-*•]\s*", "", line) for line in lines if re.match(r"^[\-*•]\s*", line)]
        if bullet_items and len(bullet_items) == len(lines):
            content.append(_bullet_list(*bullet_items))
        else:
            content.append(_paragraph(_text_node(" ".join(lines))))
    if not content:
        content = [_paragraph(_text_node("Generated automatically by Devin."))]
    return {"version": 1, "type": "doc", "content": content}


def _coerce_adf_doc(body_doc: dict | None, description_text: str = "") -> dict:
    if isinstance(body_doc, dict) and body_doc.get("type") == "doc" and isinstance(body_doc.get("content"), list):
        return body_doc
    return _doc_from_plain_text(description_text)


def _canonical_context(event: PROpenedEvent) -> list[dict]:
    return [
        _heading("Canonical Context"),
        _paragraph(_bold_text("Source repo: "), _text_node(_repo_name(event.source_repo))),
        _paragraph(_bold_text("Downstream service: "), _text_node(event.target_service)),
        _paragraph(_bold_text("Downstream repo: "), _text_node(event.target_repo)),
        _paragraph(_bold_text("Downstream PR: "), _link_node(event.pr_url, event.pr_url)),
        _paragraph(_bold_text("Devin session: "), _link_node(event.devin_session_url, event.devin_session_url)),
    ]


def _build_fields(summary: str, description_doc: dict, labels: list[str]) -> dict:
    fields: dict = {
        "project": {"key": settings.jira_project_key},
        "summary": summary,
        "description": description_doc,
        "issuetype": {"name": "Task"},
        "labels": labels,
    }
    if settings.jira_assignee_account_id:
        fields["assignee"] = {"accountId": settings.jira_assignee_account_id}
    return fields


def build_issue_fields_from_notification_bundle(
    event: PROpenedEvent,
    bundle: NotificationBundle,
) -> dict:
    """Build Jira fields from a Devin-authored notification bundle."""
    if not (bundle.jira.description_text or bundle.jira.description_adf):
        raise ValueError("missing Devin-authored Jira description in notification bundle")

    body_doc = _coerce_adf_doc(bundle.jira.description_adf, bundle.jira.description_text)
    description_doc = {
        "version": 1,
        "type": "doc",
        "content": [
            _generated_by_paragraph(),
            *body_doc.get("content", []),
            *_canonical_context(event),
        ],
    }
    labels = [*_base_labels(event), "devin-authored-notification"]
    summary = bundle.jira.summary.strip() or _default_issue_summary(event)
    return _build_fields(summary, description_doc, labels)


def build_recovery_comment(
    event: RecoveryCompleteEvent,
    billing_summary: dict | None = None,
) -> dict:
    """Build an ADF comment body for the post-incident recovery report."""
    mttr_min = event.mttr_seconds // 60
    mttr_str = f"{mttr_min}m" if mttr_min < 60 else f"{mttr_min // 60}h {mttr_min % 60}m"
    severity_label = "BREAKING" if event.is_breaking else event.severity.upper()
    routes_text = ", ".join(event.changed_routes) if event.changed_routes else "N/A"
    source_repo_name = _repo_name(event.source_repo)

    content = [
        _heading("Post-Incident Recovery Report", level=2),
        _paragraph(_bold_text("Status: "), _text_node("RESOLVED — all services remediated")),
        _generated_by_paragraph(),
        _paragraph(_bold_text("Upstream source repo: "), _text_node(source_repo_name)),
        _paragraph(_bold_text("Severity: "), _text_node(f"{severity_label} ({event.severity})")),
        _paragraph(_bold_text("MTTR: "), _text_node(mttr_str)),
        _paragraph(_bold_text("Summary: "), _text_node(event.summary or "Automated contract change recovery completed")),
        _paragraph(_bold_text("Changed routes: "), _text_node(routes_text)),
        _heading("Services Remediated", level=3),
        _bullet_list(*[
            f"{job.target_service or _repo_name(job.target_repo)} ({job.target_repo or 'unknown repo'}) — {job.pr_url or 'no PR'}"
            for job in event.jobs
        ]) if event.jobs else _paragraph(_text_node("No jobs recorded")),
    ]

    if billing_summary:
        total_revenue = billing_summary.get("total_revenue", 0)
        top_teams = billing_summary.get("top_teams", [])
        content.append(_heading("Platform Cost Context", level=3))
        content.append(_paragraph(_bold_text("Total platform spend: "), _text_node(f"${total_revenue:,.2f}")))
        if top_teams:
            content.append(_bullet_list(*[
                f"{team.get('team_name', team.get('team_id', '?'))}: ${team.get('total_cost', 0):,.2f} ({team.get('total_sessions', 0)} sessions)"
                for team in top_teams[:3]
            ]))

    return {"version": 1, "type": "doc", "content": content}
