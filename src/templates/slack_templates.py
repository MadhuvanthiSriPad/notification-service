"""Slack Block Kit message builders."""

from __future__ import annotations

import copy

from src.schemas.events import NotificationBundle, PROpenedEvent, RecoveryCompleteEvent

_SECTION_TEXT_LIMIT = 2900


def _repo_name(repo_url: str) -> str:
    return repo_url.rstrip("/").split("/")[-1] if repo_url else "unknown"


def _truncate(text: str, limit: int = _SECTION_TEXT_LIMIT) -> str:
    value = (text or "").strip()
    if len(value) <= limit:
        return value
    return f"{value[: limit - 1].rstrip()}…"


def _bullets(items: list[str], *, limit: int = 5, line_limit: int = 180) -> str:
    lines = []
    for item in items[:limit]:
        cleaned = _truncate(str(item), line_limit)
        if cleaned:
            lines.append(f"• {cleaned}")
    return "\n".join(lines)


def _section(text: str) -> dict:
    return {
        "type": "section",
        "text": {
            "type": "mrkdwn",
            "text": _truncate(text),
        },
    }


def _links_section(
    event: PROpenedEvent,
    jira_issue_key: str | None = None,
    jira_issue_url: str | None = None,
) -> dict:
    links_parts = [f":github: <{event.pr_url}|Downstream PR>"]
    if jira_issue_key and jira_issue_url:
        links_parts.append(f":jira2: <{jira_issue_url}|{jira_issue_key}>")
    links_parts.append(f":robot_face: <{event.devin_session_url}|Devin Session>")
    return {
        "type": "section",
        "text": {
            "type": "mrkdwn",
            "text": " | ".join(links_parts),
        },
    }


def _review_section() -> dict:
    return {
        "type": "section",
        "text": {
            "type": "mrkdwn",
            "text": ":point_right: *Please review and merge this downstream PR to complete the remediation.*",
        },
    }


def build_pr_notification_text(
    event: PROpenedEvent,
    jira_issue_key: str | None = None,
    jira_issue_url: str | None = None,
) -> str:
    """Plain-text fallback for Slack notifications."""
    lines = [
        "Devin downstream remediation PR ready for review",
        "Generated by: Devin via notification-service",
        f"Upstream source repo: {event.source_repo}",
        f"Downstream service: {event.target_service}",
        f"Downstream repo: {event.target_repo}",
        f"Severity: {'BREAKING' if event.is_breaking else event.severity.upper()}",
        f"Summary: {event.devin_context.brief or event.summary or 'Upstream contract change detected'}",
        f"Downstream PR: {event.pr_url}",
        f"Devin session: {event.devin_session_url}",
    ]
    if jira_issue_key and jira_issue_url:
        lines.append(f"Jira: {jira_issue_key} {jira_issue_url}")
    return "\n".join(lines)


def build_pr_notification(
    event: PROpenedEvent,
    jira_issue_key: str | None = None,
    jira_issue_url: str | None = None,
) -> list[dict]:
    """Build Block Kit blocks for a PR-opened Slack notification."""
    severity_emoji = ":red_circle:" if event.is_breaking else ":large_yellow_circle:"
    severity_label = "BREAKING" if event.is_breaking else event.severity.upper()
    source_repo_name = _repo_name(event.source_repo)
    target_repo_name = _repo_name(event.target_repo)
    brief = event.devin_context.brief or event.summary or (
        "Upstream contract change detected; downstream remediation PR raised automatically."
    )

    blocks: list[dict] = [
        {
            "type": "header",
            "text": {
                "type": "plain_text",
                "text": "Devin Downstream Remediation PR Ready for Review",
                "emoji": True,
            },
        },
        {
            "type": "section",
            "fields": [
                {
                    "type": "mrkdwn",
                    "text": f"*Generated by:*\nDevin via notification-service",
                },
                {
                    "type": "mrkdwn",
                    "text": f"*Upstream source repo:*\n`{source_repo_name}`",
                },
                {
                    "type": "mrkdwn",
                    "text": f"*Downstream service:*\n{event.target_service}",
                },
                {
                    "type": "mrkdwn",
                    "text": f"*Downstream repo:*\n`{target_repo_name}`",
                },
            ],
        },
        _section(
            "*Why this PR exists:*\n"
            f"An upstream contract change in `{source_repo_name}` affected `{event.target_service}`. "
            f"Devin opened the remediation PR in the downstream repo `{target_repo_name}`.\n\n"
            f"*Severity:* {severity_emoji} {severity_label}\n"
            f"*Summary:*\n{brief}"
        ),
    ]

    if event.devin_context.mission:
        blocks.append(_section(f"*Devin mission:*\n{event.devin_context.mission}"))

    changed_routes = event.changed_routes or event.devin_context.affected_endpoints
    if changed_routes:
        blocks.append(_section(
            "*Changed routes / affected endpoints:*\n"
            f"{_bullets(changed_routes, limit=5, line_limit=220)}"
        ))

    if event.devin_context.technical_details:
        blocks.append(_section(
            "*Technical details from Devin:*\n"
            f"{_bullets(event.devin_context.technical_details)}"
        ))

    if event.devin_context.key_files:
        blocks.append(_section(
            "*Likely downstream files touched:*\n"
            f"{_bullets(event.devin_context.key_files, line_limit=140)}"
        ))

    if event.devin_context.success_criteria:
        blocks.append(_section(
            "*Expected review checks:*\n"
            f"{_bullets(event.devin_context.success_criteria)}"
        ))

    blocks.append(_links_section(event, jira_issue_key, jira_issue_url))
    blocks.append(_review_section())
    blocks.append({"type": "divider"})

    return blocks


def build_pr_notification_from_bundle(
    event: PROpenedEvent,
    bundle: NotificationBundle,
    jira_issue_key: str | None = None,
    jira_issue_url: str | None = None,
) -> tuple[list[dict], str]:
    """Build a Slack payload from a Devin-authored notification bundle."""
    fallback_text = bundle.slack.text.strip() or build_pr_notification_text(event, jira_issue_key, jira_issue_url)
    bundle_blocks = copy.deepcopy(bundle.slack.blocks) if bundle.slack.blocks else []

    if bundle_blocks:
        blocks = bundle_blocks
    else:
        blocks = [
            {
                "type": "header",
                "text": {
                    "type": "plain_text",
                    "text": "Devin Authored Remediation Update",
                    "emoji": True,
                },
            },
            _section(fallback_text),
        ]

    blocks.append(_links_section(event, jira_issue_key, jira_issue_url))
    blocks.append(_review_section())
    blocks.append({"type": "divider"})
    return blocks, fallback_text


def build_recovery_report_text(
    event: RecoveryCompleteEvent,
    billing_summary: dict | None = None,
) -> str:
    """Plain-text fallback for the post-incident recovery report."""
    mttr_min = event.mttr_seconds // 60
    mttr_str = f"{mttr_min}m" if mttr_min < 60 else f"{mttr_min // 60}h {mttr_min % 60}m"
    job_lines = [
        f"- {job.target_service or _repo_name(job.target_repo)} ({job.target_repo or 'unknown repo'}): {job.pr_url or 'resolved without PR'}"
        for job in event.jobs
    ]
    lines = [
        "Incident resolved - contract recovery complete",
        "Generated by: Devin via notification-service",
        f"Upstream source repo: {event.source_repo}",
        f"Severity: {'BREAKING' if event.is_breaking else event.severity.upper()}",
        f"MTTR: {mttr_str}",
        f"Services fixed: {event.total_jobs}",
        f"Summary: {event.summary or 'Contract change detected and remediated automatically.'}",
    ]
    if event.changed_routes:
        lines.append(f"Changed routes: {', '.join(event.changed_routes)}")
    if job_lines:
        lines.append("Services remediated:")
        lines.extend(job_lines)
    if billing_summary:
        lines.append(f"Platform total spend: ${billing_summary.get('total_revenue', 0):,.2f}")
    return "\n".join(lines)


def build_recovery_report(
    event: RecoveryCompleteEvent,
    billing_summary: dict | None = None,
) -> list[dict]:
    """Build Block Kit blocks for the post-incident recovery report."""
    mttr_min = event.mttr_seconds // 60
    mttr_str = f"{mttr_min}m" if mttr_min < 60 else f"{mttr_min // 60}h {mttr_min % 60}m"
    severity_emoji = ":red_circle:" if event.is_breaking else ":large_yellow_circle:"
    severity_label = "BREAKING" if event.is_breaking else event.severity.upper()
    svc_list = ", ".join(event.affected_services) if event.affected_services else "unknown"

    blocks: list[dict] = [
        {
            "type": "header",
            "text": {
                "type": "plain_text",
                "text": ":white_check_mark: Incident Resolved — Contract Recovery Complete",
                "emoji": True,
            },
        },
        {
            "type": "section",
            "fields": [
                {"type": "mrkdwn", "text": "*Generated by:*\nDevin via notification-service"},
                {"type": "mrkdwn", "text": f"*Upstream source repo:*\n`{_repo_name(event.source_repo)}`"},
                {"type": "mrkdwn", "text": f"*Severity:*\n{severity_emoji} {severity_label}"},
                {"type": "mrkdwn", "text": f"*MTTR:*\n:stopwatch: {mttr_str}"},
                {"type": "mrkdwn", "text": f"*Services fixed:*\n{event.total_jobs}"},
                {"type": "mrkdwn", "text": f"*Blast radius:*\n{svc_list}"},
            ],
        },
        {
            "type": "section",
            "text": {
                "type": "mrkdwn",
                "text": f"*What changed:*\n{event.summary or 'Contract change detected and remediated automatically.'}",
            },
        },
    ]

    if event.jobs:
        pr_lines = "\n".join(
            (
                f"• `{job.target_service or _repo_name(job.target_repo)}` "
                f"(`{_repo_name(job.target_repo)}`) — <{job.pr_url}|PR merged>"
            )
            if job.pr_url else
            f"• `{job.target_service or _repo_name(job.target_repo)}` (`{_repo_name(job.target_repo)}`) — resolved"
            for job in event.jobs
        )
        blocks.append({
            "type": "section",
            "text": {"type": "mrkdwn", "text": f"*Services remediated:*\n{pr_lines}"},
        })

    if event.changed_routes:
        blocks.append(_section(
            "*Changed routes:*\n"
            f"{_bullets(event.changed_routes, limit=6, line_limit=220)}"
        ))

    if billing_summary:
        total_revenue = billing_summary.get("total_revenue", 0)
        top_teams = billing_summary.get("top_teams", [])
        cost_lines = [f":moneybag: Platform total spend: *${total_revenue:,.2f}*"]
        for team in top_teams[:3]:
            cost_lines.append(
                f"  • {team.get('team_name', '?')}: ${team.get('total_cost', 0):,.2f} "
                f"({team.get('total_sessions', 0)} sessions)"
            )
        blocks.append({
            "type": "section",
            "text": {"type": "mrkdwn", "text": "\n".join(cost_lines)},
        })

    blocks.append({"type": "divider"})
    return blocks
